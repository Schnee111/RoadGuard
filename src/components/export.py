"""
Export Module for RoadGuard
Menangani export data ke berbagai format: CSV, PDF, GeoJSON.
"""

import os
import io
import json
import base64
from datetime import datetime
from typing import List, Optional
import pandas as pd


def export_to_csv(detections: list, filename: str = None) -> tuple:
    """
    Export data deteksi ke format CSV.
    
    Args:
        detections: List of detection dicts
        filename: Optional filename (tanpa path)
        
    Returns:
        (csv_string, filename)
    """
    if not detections:
        return "", "no_data.csv"
    
    df = pd.DataFrame(detections)
    
    # Remove frame_img column (binary data)
    df = df.drop(columns=['frame_img'], errors='ignore')
    
    # Format columns
    if 'lat' in df.columns:
        df['latitude'] = df['lat']
        df = df.drop(columns=['lat'])
    if 'lon' in df.columns:
        df['longitude'] = df['lon']
        df = df.drop(columns=['lon'])
    if 'type' in df.columns:
        df['damage_type'] = df['type']
        df = df.drop(columns=['type'])
    
    # Reorder columns
    preferred_order = ['track_id', 'timestamp', 'latitude', 'longitude', 
                       'damage_type', 'conf', 'severity', 'image_path']
    cols = [c for c in preferred_order if c in df.columns]
    cols += [c for c in df.columns if c not in cols]
    df = df[cols]
    
    csv_string = df.to_csv(index=False)
    
    if not filename:
        filename = f"roadguard_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    
    return csv_string, filename


def export_to_geojson(detections: list, filename: str = None) -> tuple:
    """
    Export data deteksi ke format GeoJSON untuk GIS compatibility.
    
    Args:
        detections: List of detection dicts
        filename: Optional filename
        
    Returns:
        (geojson_string, filename)
    """
    if not detections:
        return "{}", "no_data.geojson"
    
    features = []
    
    for det in detections:
        lat = det.get('lat', det.get('latitude', 0))
        lon = det.get('lon', det.get('longitude', 0))
        
        properties = {
            "damage_type": det.get('type', det.get('damage_type', 'Unknown')),
            "timestamp": det.get('timestamp', 0),
            "confidence": det.get('conf', det.get('confidence', 0)),
            "severity": det.get('severity', 'medium'),
            "track_id": det.get('track_id', 0)
        }
        
        feature = {
            "type": "Feature",
            "geometry": {
                "type": "Point",
                "coordinates": [lon, lat]  # GeoJSON uses [lon, lat]
            },
            "properties": properties
        }
        features.append(feature)
    
    geojson = {
        "type": "FeatureCollection",
        "features": features,
        "metadata": {
            "generated_at": datetime.now().isoformat(),
            "source": "RoadGuard Vision",
            "total_features": len(features)
        }
    }
    
    if not filename:
        filename = f"roadguard_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.geojson"
    
    return json.dumps(geojson, indent=2), filename


def export_to_kml(detections: list, filename: str = None) -> tuple:
    """
    Export data deteksi ke format KML untuk Google Earth.
    
    Args:
        detections: List of detection dicts
        filename: Optional filename
        
    Returns:
        (kml_string, filename)
    """
    if not detections:
        return "", "no_data.kml"
    
    kml_header = '''<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
    <name>RoadGuard Damage Report</name>
    <description>Generated by RoadGuard Vision</description>
    
    <!-- Styles -->
    <Style id="high-severity">
        <IconStyle><color>ff0000ff</color><scale>1.2</scale></IconStyle>
    </Style>
    <Style id="medium-severity">
        <IconStyle><color>ff00a5ff</color><scale>1.0</scale></IconStyle>
    </Style>
    <Style id="low-severity">
        <IconStyle><color>ff00ff00</color><scale>0.8</scale></IconStyle>
    </Style>
'''
    
    kml_placemarks = ""
    
    for i, det in enumerate(detections):
        lat = det.get('lat', det.get('latitude', 0))
        lon = det.get('lon', det.get('longitude', 0))
        damage_type = det.get('type', det.get('damage_type', 'Unknown'))
        severity = det.get('severity', 'medium')
        timestamp = det.get('timestamp', 0)
        conf = det.get('conf', det.get('confidence', 0))
        
        kml_placemarks += f'''
    <Placemark>
        <name>{damage_type}</name>
        <description>
            <![CDATA[
                <b>Damage Type:</b> {damage_type}<br/>
                <b>Severity:</b> {severity}<br/>
                <b>Confidence:</b> {conf:.1%}<br/>
                <b>Timestamp:</b> {timestamp:.2f}s
            ]]>
        </description>
        <styleUrl>#{severity}-severity</styleUrl>
        <Point>
            <coordinates>{lon},{lat},0</coordinates>
        </Point>
    </Placemark>
'''
    
    kml_footer = '''
</Document>
</kml>'''
    
    kml_string = kml_header + kml_placemarks + kml_footer
    
    if not filename:
        filename = f"roadguard_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.kml"
    
    return kml_string, filename


def generate_pdf_report(detections: list, stats: dict = None, 
                       session_info: dict = None) -> bytes:
    """
    Generate PDF report (requires reportlab).
    
    Args:
        detections: List of detection dicts
        stats: Optional statistics dict
        session_info: Optional session information
        
    Returns:
        PDF bytes
    """
    try:
        from reportlab.lib import colors
        from reportlab.lib.pagesizes import A4
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch, cm
        from reportlab.platypus import (
            SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle,
            Image, PageBreak
        )
        from reportlab.lib.enums import TA_CENTER, TA_LEFT
    except ImportError:
        # Fallback: return simple text
        return _generate_text_report(detections, stats, session_info).encode('utf-8')
    
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, 
                           rightMargin=72, leftMargin=72,
                           topMargin=72, bottomMargin=72)
    
    styles = getSampleStyleSheet()
    styles.add(ParagraphStyle(name='Title2', 
                             parent=styles['Title'],
                             fontSize=24,
                             spaceAfter=30))
    styles.add(ParagraphStyle(name='Subtitle',
                             parent=styles['Normal'],
                             fontSize=12,
                             textColor=colors.grey,
                             alignment=TA_CENTER,
                             spaceAfter=20))
    
    story = []
    
    # Title
    story.append(Paragraph("RoadGuard Vision", styles['Title2']))
    story.append(Paragraph("Road Damage Inspection Report", styles['Subtitle']))
    story.append(Paragraph(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", 
                          styles['Subtitle']))
    story.append(Spacer(1, 20))
    
    # Session Info
    if session_info:
        story.append(Paragraph("Session Information", styles['Heading2']))
        session_data = [
            ["Session ID", session_info.get('id', 'N/A')],
            ["Start Time", session_info.get('start_time', 'N/A')],
            ["End Time", session_info.get('end_time', 'N/A')],
            ["Video Source", session_info.get('video_source', 'N/A')],
        ]
        table = Table(session_data, colWidths=[2*inch, 4*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('PADDING', (0, 0), (-1, -1), 8),
        ]))
        story.append(table)
        story.append(Spacer(1, 20))
    
    # Statistics
    story.append(Paragraph("Summary Statistics", styles['Heading2']))
    
    if stats:
        stat_data = [
            ["Total Damages", str(stats.get('total_damages', len(detections)))],
            ["High Severity", str(stats.get('by_severity', {}).get('high', 0))],
            ["Medium Severity", str(stats.get('by_severity', {}).get('medium', 0))],
            ["Low Severity", str(stats.get('by_severity', {}).get('low', 0))],
        ]
    else:
        # Calculate from detections
        df = pd.DataFrame(detections)
        sev_counts = df['severity'].value_counts() if 'severity' in df.columns else {}
        stat_data = [
            ["Total Damages", str(len(detections))],
            ["High Severity", str(sev_counts.get('high', 0))],
            ["Medium Severity", str(sev_counts.get('medium', 0))],
            ["Low Severity", str(sev_counts.get('low', 0))],
        ]
    
    table = Table(stat_data, colWidths=[2*inch, 2*inch])
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('PADDING', (0, 0), (-1, -1), 8),
        ('ALIGN', (1, 0), (1, -1), 'CENTER'),
    ]))
    story.append(table)
    story.append(Spacer(1, 20))
    
    # Damage by Type
    story.append(Paragraph("Damage Type Distribution", styles['Heading2']))
    
    df = pd.DataFrame(detections)
    type_col = 'type' if 'type' in df.columns else 'damage_type'
    if type_col in df.columns:
        type_counts = df[type_col].value_counts()
        type_data = [["Damage Type", "Count", "Percentage"]]
        for dtype, count in type_counts.items():
            pct = count / len(detections) * 100
            type_data.append([dtype, str(count), f"{pct:.1f}%"])
        
        table = Table(type_data, colWidths=[3*inch, 1*inch, 1.5*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.darkblue),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('PADDING', (0, 0), (-1, -1), 8),
            ('ALIGN', (1, 0), (-1, -1), 'CENTER'),
        ]))
        story.append(table)
    
    story.append(PageBreak())
    
    # Detailed Damage List
    story.append(Paragraph("Detailed Damage Records", styles['Heading2']))
    
    # Table header
    detail_data = [["#", "Type", "Location", "Time", "Severity"]]
    
    for i, det in enumerate(detections[:50], 1):  # Limit to 50
        lat = det.get('lat', det.get('latitude', 0))
        lon = det.get('lon', det.get('longitude', 0))
        
        detail_data.append([
            str(i),
            det.get('type', det.get('damage_type', 'N/A')),
            f"{lat:.5f}, {lon:.5f}",
            f"{det.get('timestamp', 0):.1f}s",
            det.get('severity', 'medium')
        ])
    
    table = Table(detail_data, colWidths=[0.5*inch, 2*inch, 2*inch, 0.8*inch, 1*inch])
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.darkblue),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('PADDING', (0, 0), (-1, -1), 6),
        ('FONTSIZE', (0, 0), (-1, -1), 9),
        ('ALIGN', (0, 0), (0, -1), 'CENTER'),
        ('ALIGN', (3, 0), (4, -1), 'CENTER'),
    ]))
    story.append(table)
    
    if len(detections) > 50:
        story.append(Spacer(1, 10))
        story.append(Paragraph(f"... and {len(detections) - 50} more records", 
                              styles['Normal']))
    
    # Build PDF
    doc.build(story)
    
    return buffer.getvalue()


def _generate_text_report(detections: list, stats: dict = None, 
                         session_info: dict = None) -> str:
    """Fallback text report jika reportlab tidak tersedia"""
    lines = []
    lines.append("=" * 60)
    lines.append("ROADGUARD VISION - DAMAGE INSPECTION REPORT")
    lines.append("=" * 60)
    lines.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append("")
    
    if session_info:
        lines.append("SESSION INFORMATION")
        lines.append("-" * 40)
        for key, value in session_info.items():
            lines.append(f"  {key}: {value}")
        lines.append("")
    
    lines.append("SUMMARY")
    lines.append("-" * 40)
    lines.append(f"  Total Damages: {len(detections)}")
    
    if detections:
        df = pd.DataFrame(detections)
        if 'severity' in df.columns:
            sev_counts = df['severity'].value_counts()
            lines.append(f"  High Severity: {sev_counts.get('high', 0)}")
            lines.append(f"  Medium Severity: {sev_counts.get('medium', 0)}")
            lines.append(f"  Low Severity: {sev_counts.get('low', 0)}")
    
    lines.append("")
    lines.append("DAMAGE RECORDS")
    lines.append("-" * 40)
    
    for i, det in enumerate(detections[:20], 1):
        lat = det.get('lat', det.get('latitude', 0))
        lon = det.get('lon', det.get('longitude', 0))
        dtype = det.get('type', det.get('damage_type', 'N/A'))
        lines.append(f"{i}. {dtype} at ({lat:.5f}, {lon:.5f})")
    
    if len(detections) > 20:
        lines.append(f"... and {len(detections) - 20} more")
    
    lines.append("")
    lines.append("=" * 60)
    
    return "\n".join(lines)


def render_export_buttons(detections: list, db=None, session_id: str = None):
    """
    Render tombol-tombol export di Streamlit.
    
    Args:
        detections: List of detection dicts
        db: Optional DamageDatabase instance
        session_id: Optional session ID untuk filter
    """
    import streamlit as st
    
    st.markdown("### üì• Export Options")
    
    if not detections:
        st.warning("No data to export.")
        return
    
    col1, col2, col3, col4 = st.columns(4)
    
    # CSV Export
    with col1:
        csv_data, csv_filename = export_to_csv(detections)
        st.download_button(
            label="üìä CSV",
            data=csv_data,
            file_name=csv_filename,
            mime="text/csv",
            use_container_width=True
        )
    
    # GeoJSON Export
    with col2:
        geojson_data, geojson_filename = export_to_geojson(detections)
        st.download_button(
            label="üó∫Ô∏è GeoJSON",
            data=geojson_data,
            file_name=geojson_filename,
            mime="application/json",
            use_container_width=True
        )
    
    # KML Export
    with col3:
        kml_data, kml_filename = export_to_kml(detections)
        st.download_button(
            label="üåç KML",
            data=kml_data,
            file_name=kml_filename,
            mime="application/vnd.google-earth.kml+xml",
            use_container_width=True
        )
    
    # PDF Report
    with col4:
        try:
            stats = None
            session_info = None
            
            if db and session_id:
                stats = db.get_statistics()
                sessions = db.get_all_sessions()
                session_info = next((s for s in sessions if s['id'] == session_id), None)
            
            pdf_data = generate_pdf_report(detections, stats, session_info)
            pdf_filename = f"roadguard_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            
            st.download_button(
                label="üìÑ PDF",
                data=pdf_data,
                file_name=pdf_filename,
                mime="application/pdf",
                use_container_width=True
            )
        except Exception as e:
            if st.button("üìÑ PDF", use_container_width=True, disabled=True):
                pass
            st.caption("Install reportlab untuk PDF")
